{"version":3,"sources":["webpack:///scripts.f3d2f5a0b72a22108b70.bundle.js","webpack:////Users/philmerrell/dev/Scrum-Poker/~/script-loader/addScript.js","webpack:////Users/philmerrell/dev/Scrum-Poker/~/ramjet/dist/ramjet.umd.js?87db","webpack:////Users/philmerrell/dev/Scrum-Poker/~/ramjet/dist/ramjet.umd.js"],"names":["webpackJsonp","1058","module","exports","src","execScript","eval","call","1061","__webpack_require__","483","793"],"mappings":"AAAAA,cAAc,EAAE,IAEVC,KACA,SAASC,EAAQC,GCCvBD,EAAAC,QAAA,SAAAC,GACA,mBAAAC,YACAA,WAAAD,GAEAE,KAAAC,KAAA,KAAAH,KDWMI,KACA,SAASN,EAAQC,EAASM,GAEhCP,EAAOC,QAAUM,EAAoB,MAK/BC,IACA,SAASR,EAAQC,EAASM,GE5BhCA,EAAA,MAAAA,EAAA,OFkCME,IACA,SAAST,EAAQC,GGnCvBD,EAAAC,QAAA,krqBHyCG","file":"scripts.f3d2f5a0b72a22108b70.bundle.js","sourcesContent":["webpackJsonp([1,3],{\n\n/***/ 1058:\n/***/ function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n/***/ },\n\n/***/ 1061:\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(483);\n\n\n/***/ },\n\n/***/ 483:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(1058)(__webpack_require__(793))\n\n/***/ },\n\n/***/ 793:\n/***/ function(module, exports) {\n\nmodule.exports = \"(function (global, factory) {\\n            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n            typeof define === 'function' && define.amd ? define(factory) :\\n            (global.ramjet = factory());\\n}(this, function () { 'use strict';\\n\\n            var babelHelpers = {};\\n\\n            babelHelpers.classCallCheck = function (instance, Constructor) {\\n              if (!(instance instanceof Constructor)) {\\n                throw new TypeError(\\\"Cannot call a class as a function\\\");\\n              }\\n            };\\n\\n            babelHelpers;\\n\\n            // for the sake of Safari, may it burn in hell\\n            var BLACKLIST = ['length', 'parentRule'];\\n\\n            var styleKeys = undefined;\\n\\n            if (typeof CSS2Properties !== 'undefined') {\\n            \\t// why hello Firefox\\n            \\tstyleKeys = Object.keys(CSS2Properties.prototype);\\n            } else {\\n            \\tstyleKeys = Object.keys(document.createElement('div').style).filter(function (k) {\\n            \\t\\treturn ! ~BLACKLIST.indexOf(k);\\n            \\t});\\n            }\\n\\n            var styleKeys$1 = styleKeys;\\n\\n            var svgns = 'http://www.w3.org/2000/svg';\\n            var svg = undefined;\\n            try {\\n            \\tsvg = document.createElementNS(svgns, 'svg');\\n\\n            \\tsvg.style.position = 'fixed';\\n            \\tsvg.style.top = svg.style.left = '0';\\n            \\tsvg.style.width = svg.style.height = '100%';\\n            \\tsvg.style.overflow = 'visible';\\n            \\tsvg.style.pointerEvents = 'none';\\n            \\tsvg.setAttribute('class', 'mogrify-svg');\\n            } catch (e) {\\n            \\tconsole.log(\\\"The current browser doesn't support SVG\\\");\\n            }\\n\\n            var appendedSvg = false;\\n\\n            function appendSvg() {\\n            \\tdocument.body.appendChild(svg);\\n            \\tappendedSvg = true;\\n            }\\n\\n            function cloneNode(node, depth, overrideClone) {\\n            \\tvar clone = overrideClone ? overrideClone(node, depth) : node.cloneNode();\\n\\n            \\tif (typeof clone === \\\"undefined\\\") {\\n            \\t\\treturn;\\n            \\t}\\n\\n            \\tvar style = undefined;\\n            \\tvar len = undefined;\\n            \\tvar i = undefined;\\n            \\tvar clonedNode = undefined;\\n\\n            \\tif (node.nodeType === 1) {\\n            \\t\\tstyle = window.getComputedStyle(node);\\n\\n            \\t\\tstyleKeys$1.forEach(function (prop) {\\n            \\t\\t\\tclone.style[prop] = style[prop];\\n            \\t\\t});\\n\\n            \\t\\tlen = node.childNodes.length;\\n            \\t\\tfor (i = 0; i < len; i += 1) {\\n            \\t\\t\\tclonedNode = cloneNode(node.childNodes[i], depth + 1, overrideClone);\\n            \\t\\t\\tif (clonedNode) {\\n            \\t\\t\\t\\tclone.appendChild(clonedNode);\\n            \\t\\t\\t}\\n            \\t\\t}\\n            \\t}\\n\\n            \\treturn clone;\\n            }\\n\\n            function wrapNode(node, destinationIsFixed, overrideClone, appendToBody) {\\n            \\tvar isSvg = node.namespaceURI === svgns;\\n\\n            \\tvar _node$getBoundingClie = node.getBoundingClientRect();\\n\\n            \\tvar left = _node$getBoundingClie.left;\\n            \\tvar right = _node$getBoundingClie.right;\\n            \\tvar top = _node$getBoundingClie.top;\\n            \\tvar bottom = _node$getBoundingClie.bottom;\\n\\n            \\tvar style = window.getComputedStyle(node);\\n            \\tvar clone = cloneNode(node, 0, overrideClone);\\n\\n            \\tvar wrapper = {\\n            \\t\\tnode: node, clone: clone, isSvg: isSvg,\\n            \\t\\tcx: (left + right) / 2,\\n            \\t\\tcy: (top + bottom) / 2,\\n            \\t\\twidth: right - left,\\n            \\t\\theight: bottom - top,\\n            \\t\\ttransform: null,\\n            \\t\\tborderRadius: null\\n            \\t};\\n\\n            \\tif (isSvg) {\\n            \\t\\tvar ctm = node.getScreenCTM();\\n            \\t\\twrapper.transform = 'matrix(' + [ctm.a, ctm.b, ctm.c, ctm.d, ctm.e, ctm.f].join(',') + ')';\\n            \\t\\twrapper.borderRadius = [0, 0, 0, 0];\\n\\n            \\t\\tsvg.appendChild(clone);\\n            \\t} else {\\n\\n            \\t\\tif (destinationIsFixed) {\\n            \\t\\t\\t// position relative to the viewport\\n            \\t\\t\\tclone.style.position = 'fixed';\\n            \\t\\t\\tclone.style.top = top - parseInt(style.marginTop, 10) + 'px';\\n            \\t\\t\\tclone.style.left = left - parseInt(style.marginLeft, 10) + 'px';\\n            \\t\\t} else {\\n            \\t\\t\\tvar offsetParent = node.offsetParent;\\n\\n            \\t\\t\\tif (offsetParent === null || offsetParent === document.body || appendToBody) {\\n            \\t\\t\\t\\t// parent is fixed, or I want to append the node to the body\\n            \\t\\t\\t\\t// position relative to the document\\n            \\t\\t\\t\\tvar docElem = document.documentElement;\\n            \\t\\t\\t\\tclone.style.position = 'absolute';\\n            \\t\\t\\t\\tclone.style.top = top + window.pageYOffset - docElem.clientTop - parseInt(style.marginTop, 10) + 'px';\\n            \\t\\t\\t\\tclone.style.left = left + window.pageXOffset - docElem.clientLeft - parseInt(style.marginLeft, 10) + 'px';\\n            \\t\\t\\t} else {\\n            \\t\\t\\t\\t//position relative to the parent\\n            \\t\\t\\t\\tvar offsetParentStyle = window.getComputedStyle(offsetParent);\\n            \\t\\t\\t\\tvar offsetParentBcr = offsetParent.getBoundingClientRect();\\n\\n            \\t\\t\\t\\tclone.style.position = 'absolute';\\n            \\t\\t\\t\\tclone.style.top = top - parseInt(style.marginTop, 10) - (offsetParentBcr.top - parseInt(offsetParentStyle.marginTop, 10)) + 'px';\\n            \\t\\t\\t\\tclone.style.left = left - parseInt(style.marginLeft, 10) - (offsetParentBcr.left - parseInt(offsetParentStyle.marginLeft, 10)) + 'px';\\n            \\t\\t\\t}\\n            \\t\\t}\\n\\n            \\t\\twrapper.transform = ''; // TODO...?\\n            \\t\\twrapper.borderRadius = [parseFloat(style.borderTopLeftRadius), parseFloat(style.borderTopRightRadius), parseFloat(style.borderBottomRightRadius), parseFloat(style.borderBottomLeftRadius)];\\n\\n            \\t\\tif (appendToBody) {\\n            \\t\\t\\tdocument.body.appendChild(clone);\\n            \\t\\t} else {\\n            \\t\\t\\tnode.parentNode.appendChild(clone);\\n            \\t\\t}\\n            \\t}\\n\\n            \\treturn wrapper;\\n            }\\n\\n            function hideNode(node) {\\n            \\tnode.__ramjetOriginalTransition__ = node.style.transition;\\n            \\tnode.style.transition = '';\\n\\n            \\tnode.style.opacity = 0;\\n            }\\n\\n            function showNode(node) {\\n            \\tnode.style.transition = '';\\n            \\tnode.style.opacity = 1;\\n\\n            \\tif (node.__ramjetOriginalTransition__) {\\n            \\t\\tsetTimeout(function () {\\n            \\t\\t\\tnode.style.transition = node.__ramjetOriginalTransition__;\\n            \\t\\t});\\n            \\t}\\n            }\\n\\n            function isNodeFixed(node) {\\n            \\twhile (node !== null) {\\n            \\t\\tif (window.getComputedStyle(node).position === \\\"fixed\\\") {\\n            \\t\\t\\treturn true;\\n            \\t\\t}\\n            \\t\\tnode = node.namespaceURI === svgns ? node.parentNode : node.offsetParent;\\n            \\t}\\n            \\treturn false;\\n            }\\n\\n            function getTransform(isSvg, cx, cy, dx, dy, dsx, dsy, t, t_scale) {\\n            \\tvar transform = isSvg ? \\\"translate(\\\" + cx + \\\" \\\" + cy + \\\") scale(\\\" + (1 + t_scale * dsx) + \\\" \\\" + (1 + t_scale * dsy) + \\\") translate(\\\" + -cx + \\\" \\\" + -cy + \\\") translate(\\\" + t * dx + \\\" \\\" + t * dy + \\\")\\\" : \\\"translate(\\\" + t * dx + \\\"px,\\\" + t * dy + \\\"px) scale(\\\" + (1 + t_scale * dsx) + \\\",\\\" + (1 + t_scale * dsy) + \\\")\\\";\\n\\n            \\treturn transform;\\n            }\\n\\n            function getBorderRadius(a, b, dsx, dsy, t) {\\n            \\tvar sx = 1 + t * dsx;\\n            \\tvar sy = 1 + t * dsy;\\n\\n            \\treturn a.map(function (from, i) {\\n            \\t\\tvar to = b[i];\\n\\n            \\t\\tvar rx = (from + t * (to - from)) / sx;\\n            \\t\\tvar ry = (from + t * (to - from)) / sy;\\n\\n            \\t\\treturn rx + \\\"px \\\" + ry + \\\"px\\\";\\n            \\t});\\n            }\\n\\n            function linear(pos) {\\n            \\treturn pos;\\n            }\\n\\n            function easeIn(pos) {\\n            \\treturn Math.pow(pos, 3);\\n            }\\n\\n            function easeOut(pos) {\\n            \\treturn Math.pow(pos - 1, 3) + 1;\\n            }\\n\\n            function easeInOut(pos) {\\n            \\tif ((pos /= 0.5) < 1) {\\n            \\t\\treturn 0.5 * Math.pow(pos, 3);\\n            \\t}\\n\\n            \\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\\n            }\\n\\n            var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\\n                        return setTimeout(fn, 16);\\n            };\\n\\n            var TimerTransformer = function TimerTransformer(from, to, options) {\\n            \\tbabelHelpers.classCallCheck(this, TimerTransformer);\\n\\n            \\tvar dx = to.cx - from.cx;\\n            \\tvar dy = to.cy - from.cy;\\n\\n            \\tvar dsxf = to.width / from.width - 1;\\n            \\tvar dsyf = to.height / from.height - 1;\\n\\n            \\tvar dsxt = from.width / to.width - 1;\\n            \\tvar dsyt = from.height / to.height - 1;\\n\\n            \\tvar startTime = Date.now();\\n            \\tvar duration = options.duration || 400;\\n            \\tvar easing = options.easing || linear;\\n            \\tvar easingScale = options.easingScale || easing;\\n\\n            \\tfunction tick() {\\n            \\t\\tvar timeNow = Date.now();\\n            \\t\\tvar elapsed = timeNow - startTime;\\n\\n            \\t\\tif (elapsed > duration) {\\n            \\t\\t\\tfrom.clone.parentNode.removeChild(from.clone);\\n            \\t\\t\\tto.clone.parentNode.removeChild(to.clone);\\n\\n            \\t\\t\\tif (options.done) {\\n            \\t\\t\\t\\toptions.done();\\n            \\t\\t\\t}\\n\\n            \\t\\t\\treturn;\\n            \\t\\t}\\n\\n            \\t\\tvar t = easing(elapsed / duration);\\n            \\t\\tvar t_scale = easingScale(elapsed / duration);\\n\\n            \\t\\t// opacity\\n            \\t\\tfrom.clone.style.opacity = 1 - t;\\n            \\t\\tto.clone.style.opacity = t;\\n\\n            \\t\\t// border radius\\n            \\t\\tvar fromBorderRadius = getBorderRadius(from.borderRadius, to.borderRadius, dsxf, dsyf, t);\\n            \\t\\tvar toBorderRadius = getBorderRadius(to.borderRadius, from.borderRadius, dsxt, dsyt, 1 - t);\\n\\n            \\t\\tapplyBorderRadius(from.clone, fromBorderRadius);\\n            \\t\\tapplyBorderRadius(to.clone, toBorderRadius);\\n\\n            \\t\\tvar cx = from.cx + dx * t;\\n            \\t\\tvar cy = from.cy + dy * t;\\n\\n            \\t\\tvar fromTransform = getTransform(from.isSvg, cx, cy, dx, dy, dsxf, dsyf, t, t_scale) + ' ' + from.transform;\\n            \\t\\tvar toTransform = getTransform(to.isSvg, cx, cy, -dx, -dy, dsxt, dsyt, 1 - t, 1 - t_scale) + ' ' + to.transform;\\n\\n            \\t\\tif (from.isSvg) {\\n            \\t\\t\\tfrom.clone.setAttribute('transform', fromTransform);\\n            \\t\\t} else {\\n            \\t\\t\\tfrom.clone.style.transform = from.clone.style.webkitTransform = from.clone.style.msTransform = fromTransform;\\n            \\t\\t}\\n\\n            \\t\\tif (to.isSvg) {\\n            \\t\\t\\tto.clone.setAttribute('transform', toTransform);\\n            \\t\\t} else {\\n            \\t\\t\\tto.clone.style.transform = to.clone.style.webkitTransform = to.clone.style.msTransform = toTransform;\\n            \\t\\t}\\n\\n            \\t\\trAF(tick);\\n            \\t}\\n\\n            \\ttick();\\n            };\\n\\n            function applyBorderRadius(node, borderRadius) {\\n            \\tnode.style.borderTopLeftRadius = borderRadius[0];\\n            \\tnode.style.borderTopRightRadius = borderRadius[1];\\n            \\tnode.style.borderBottomRightRadius = borderRadius[2];\\n            \\tnode.style.borderBottomLeftRadius = borderRadius[3];\\n            }\\n\\n            var div = document.createElement('div');\\n\\n            var keyframesSupported = true;\\n            var TRANSFORM = undefined;\\n            var KEYFRAMES = undefined;\\n            var ANIMATION_DIRECTION = undefined;\\n            var ANIMATION_DURATION = undefined;\\n            var ANIMATION_ITERATION_COUNT = undefined;\\n            var ANIMATION_NAME = undefined;\\n            var ANIMATION_TIMING_FUNCTION = undefined;\\n            var ANIMATION_END = undefined;\\n\\n            // We have to browser-sniff for IE11, because it was apparently written\\n            // by a barrel of stoned monkeys - http://jsfiddle.net/rich_harris/oquLu2qL/\\n\\n            // http://stackoverflow.com/questions/17907445/how-to-detect-ie11\\n            var isIe11 = !window.ActiveXObject && 'ActiveXObject' in window;\\n\\n            if (!isIe11 && ('transform' in div.style || 'webkitTransform' in div.style) && ('animation' in div.style || 'webkitAnimation' in div.style)) {\\n            \\tkeyframesSupported = true;\\n\\n            \\tTRANSFORM = 'transform' in div.style ? 'transform' : '-webkit-transform';\\n\\n            \\tif ('animation' in div.style) {\\n            \\t\\tKEYFRAMES = '@keyframes';\\n\\n            \\t\\tANIMATION_DIRECTION = 'animationDirection';\\n            \\t\\tANIMATION_DURATION = 'animationDuration';\\n            \\t\\tANIMATION_ITERATION_COUNT = 'animationIterationCount';\\n            \\t\\tANIMATION_NAME = 'animationName';\\n            \\t\\tANIMATION_TIMING_FUNCTION = 'animationTimingFunction';\\n\\n            \\t\\tANIMATION_END = 'animationend';\\n            \\t} else {\\n            \\t\\tKEYFRAMES = '@-webkit-keyframes';\\n\\n            \\t\\tANIMATION_DIRECTION = 'webkitAnimationDirection';\\n            \\t\\tANIMATION_DURATION = 'webkitAnimationDuration';\\n            \\t\\tANIMATION_ITERATION_COUNT = 'webkitAnimationIterationCount';\\n            \\t\\tANIMATION_NAME = 'webkitAnimationName';\\n            \\t\\tANIMATION_TIMING_FUNCTION = 'webkitAnimationTimingFunction';\\n\\n            \\t\\tANIMATION_END = 'webkitAnimationEnd';\\n            \\t}\\n            } else {\\n            \\tkeyframesSupported = false;\\n            }\\n\\n            var KeyframeTransformer = function KeyframeTransformer(from, to, options) {\\n            \\tbabelHelpers.classCallCheck(this, KeyframeTransformer);\\n\\n            \\tvar _getKeyframes = getKeyframes(from, to, options);\\n\\n            \\tvar fromKeyframes = _getKeyframes.fromKeyframes;\\n            \\tvar toKeyframes = _getKeyframes.toKeyframes;\\n\\n            \\tvar fromId = '_' + ~ ~(Math.random() * 1000000);\\n            \\tvar toId = '_' + ~ ~(Math.random() * 1000000);\\n\\n            \\tvar css = KEYFRAMES + ' ' + fromId + ' { ' + fromKeyframes + ' } ' + KEYFRAMES + ' ' + toId + ' { ' + toKeyframes + ' }';\\n            \\tvar dispose = addCss(css);\\n\\n            \\tfrom.clone.style[ANIMATION_DIRECTION] = 'alternate';\\n            \\tfrom.clone.style[ANIMATION_DURATION] = options.duration / 1000 + 's';\\n            \\tfrom.clone.style[ANIMATION_ITERATION_COUNT] = 1;\\n            \\tfrom.clone.style[ANIMATION_NAME] = fromId;\\n            \\tfrom.clone.style[ANIMATION_TIMING_FUNCTION] = 'linear';\\n\\n            \\tto.clone.style[ANIMATION_DIRECTION] = 'alternate';\\n            \\tto.clone.style[ANIMATION_DURATION] = options.duration / 1000 + 's';\\n            \\tto.clone.style[ANIMATION_ITERATION_COUNT] = 1;\\n            \\tto.clone.style[ANIMATION_NAME] = toId;\\n            \\tto.clone.style[ANIMATION_TIMING_FUNCTION] = 'linear';\\n\\n            \\tvar fromDone = undefined;\\n            \\tvar toDone = undefined;\\n\\n            \\tfunction done() {\\n            \\t\\tif (fromDone && toDone) {\\n            \\t\\t\\tfrom.clone.parentNode.removeChild(from.clone);\\n            \\t\\t\\tto.clone.parentNode.removeChild(to.clone);\\n\\n            \\t\\t\\tif (options.done) options.done();\\n\\n            \\t\\t\\tdispose();\\n            \\t\\t}\\n            \\t}\\n\\n            \\tfrom.clone.addEventListener(ANIMATION_END, function () {\\n            \\t\\tfromDone = true;\\n            \\t\\tdone();\\n            \\t});\\n\\n            \\tto.clone.addEventListener(ANIMATION_END, function () {\\n            \\t\\ttoDone = true;\\n            \\t\\tdone();\\n            \\t});\\n            };\\n\\n            function addCss(css) {\\n            \\tvar styleElement = document.createElement('style');\\n            \\tstyleElement.type = 'text/css';\\n\\n            \\tvar head = document.getElementsByTagName('head')[0];\\n\\n            \\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\\n            \\t// use styleSheet.cssText instead\\n            \\tvar styleSheet = styleElement.styleSheet;\\n\\n            \\tif (styleSheet) {\\n            \\t\\tstyleSheet.cssText = css;\\n            \\t} else {\\n            \\t\\tstyleElement.innerHTML = css;\\n            \\t}\\n\\n            \\thead.appendChild(styleElement);\\n\\n            \\treturn function () {\\n            \\t\\treturn head.removeChild(styleElement);\\n            \\t};\\n            }\\n\\n            function getKeyframes(from, to, options) {\\n            \\tvar dx = to.cx - from.cx;\\n            \\tvar dy = to.cy - from.cy;\\n\\n            \\tvar dsxf = to.width / from.width - 1;\\n            \\tvar dsyf = to.height / from.height - 1;\\n\\n            \\tvar dsxt = from.width / to.width - 1;\\n            \\tvar dsyt = from.height / to.height - 1;\\n\\n            \\tvar easing = options.easing || linear;\\n            \\tvar easingScale = options.easingScale || easing;\\n\\n            \\tvar numFrames = options.duration / 50; // one keyframe per 50ms is probably enough... this may prove not to be the case though\\n\\n            \\tvar fromKeyframes = [];\\n            \\tvar toKeyframes = [];\\n            \\tvar i;\\n\\n            \\tfunction addKeyframes(pc, t, t_scale) {\\n            \\t\\tvar cx = from.cx + dx * t;\\n            \\t\\tvar cy = from.cy + dy * t;\\n\\n            \\t\\tvar fromBorderRadius = getBorderRadius(from.borderRadius, to.borderRadius, dsxf, dsyf, t);\\n            \\t\\tvar toBorderRadius = getBorderRadius(to.borderRadius, from.borderRadius, dsxt, dsyt, 1 - t);\\n\\n            \\t\\tvar fromTransform = getTransform(false, cx, cy, dx, dy, dsxf, dsyf, t, t_scale) + ' ' + from.transform;\\n            \\t\\tvar toTransform = getTransform(false, cx, cy, -dx, -dy, dsxt, dsyt, 1 - t, 1 - t_scale) + ' ' + to.transform;\\n\\n            \\t\\tfromKeyframes.push('\\\\n\\\\t\\\\t\\\\t' + pc + '% {\\\\n\\\\t\\\\t\\\\t\\\\topacity: ' + (1 - t) + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-left-radius: ' + fromBorderRadius[0] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-right-radius: ' + fromBorderRadius[1] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-right-radius: ' + fromBorderRadius[2] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-left-radius: ' + fromBorderRadius[3] + ';\\\\n\\\\t\\\\t\\\\t\\\\t' + TRANSFORM + ': ' + fromTransform + ';\\\\n\\\\t\\\\t\\\\t}');\\n\\n            \\t\\ttoKeyframes.push('\\\\n\\\\t\\\\t\\\\t' + pc + '% {\\\\n\\\\t\\\\t\\\\t\\\\topacity: ' + t + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-left-radius: ' + toBorderRadius[0] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-right-radius: ' + toBorderRadius[1] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-right-radius: ' + toBorderRadius[2] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-left-radius: ' + toBorderRadius[3] + ';\\\\n\\\\t\\\\t\\\\t\\\\t' + TRANSFORM + ': ' + toTransform + ';\\\\n\\\\t\\\\t\\\\t}');\\n            \\t}\\n\\n            \\tfor (i = 0; i < numFrames; i += 1) {\\n            \\t\\tvar pc = 100 * (i / numFrames);\\n            \\t\\tvar t = easing(i / numFrames);\\n            \\t\\tvar t_scale = easingScale(i / numFrames);\\n\\n            \\t\\taddKeyframes(pc, t, t_scale);\\n            \\t}\\n\\n            \\taddKeyframes(100, 1, 1);\\n\\n            \\tfromKeyframes = fromKeyframes.join('\\\\n');\\n            \\ttoKeyframes = toKeyframes.join('\\\\n');\\n\\n            \\treturn { fromKeyframes: fromKeyframes, toKeyframes: toKeyframes };\\n            }\\n\\n            var ramjet = {\\n            \\ttransform: function transform(fromNode, toNode) {\\n            \\t\\tvar options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n            \\t\\tif (typeof options === 'function') {\\n            \\t\\t\\toptions = { done: options };\\n            \\t\\t}\\n\\n            \\t\\tif (!('duration' in options)) {\\n            \\t\\t\\toptions.duration = 400;\\n            \\t\\t}\\n\\n            \\t\\tvar appendToBody = !!options.appendToBody;\\n            \\t\\tvar destinationIsFixed = isNodeFixed(toNode);\\n            \\t\\tvar from = wrapNode(fromNode, destinationIsFixed, options.overrideClone, appendToBody);\\n            \\t\\tvar to = wrapNode(toNode, destinationIsFixed, options.overrideClone, appendToBody);\\n\\n            \\t\\tif (from.isSvg || to.isSvg && !appendedSvg) {\\n            \\t\\t\\tappendSvg();\\n            \\t\\t}\\n\\n            \\t\\tif (!keyframesSupported || options.useTimer || from.isSvg || to.isSvg) {\\n            \\t\\t\\treturn new TimerTransformer(from, to, options);\\n            \\t\\t} else {\\n            \\t\\t\\treturn new KeyframeTransformer(from, to, options);\\n            \\t\\t}\\n            \\t},\\n            \\thide: function hide() {\\n            \\t\\tfor (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\\n            \\t\\t\\tnodes[_key] = arguments[_key];\\n            \\t\\t}\\n\\n            \\t\\tnodes.forEach(hideNode);\\n            \\t},\\n            \\tshow: function show() {\\n            \\t\\tfor (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n            \\t\\t\\tnodes[_key2] = arguments[_key2];\\n            \\t\\t}\\n\\n            \\t\\tnodes.forEach(showNode);\\n            \\t},\\n\\n            \\t// expose some basic easing functions\\n            \\tlinear: linear, easeIn: easeIn, easeOut: easeOut, easeInOut: easeInOut\\n            };\\n\\n            return ramjet;\\n\\n}));\\n//# sourceMappingURL=ramjet.umd.js.map\\n\"\n\n/***/ }\n\n},[1061]);\n\n\n// WEBPACK FOOTER //\n// scripts.f3d2f5a0b72a22108b70.bundle.js","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/philmerrell/dev/Scrum-Poker/~/script-loader/addScript.js\n// module id = 1058\n// module chunks = 1","require(\"!!/Users/philmerrell/dev/Scrum-Poker/node_modules/script-loader/addScript.js\")(require(\"!!/Users/philmerrell/dev/Scrum-Poker/node_modules/raw-loader/index.js!/Users/philmerrell/dev/Scrum-Poker/node_modules/ramjet/dist/ramjet.umd.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/philmerrell/dev/Scrum-Poker/~/ramjet/dist/ramjet.umd.js\n// module id = 483\n// module chunks = 1","module.exports = \"(function (global, factory) {\\n            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n            typeof define === 'function' && define.amd ? define(factory) :\\n            (global.ramjet = factory());\\n}(this, function () { 'use strict';\\n\\n            var babelHelpers = {};\\n\\n            babelHelpers.classCallCheck = function (instance, Constructor) {\\n              if (!(instance instanceof Constructor)) {\\n                throw new TypeError(\\\"Cannot call a class as a function\\\");\\n              }\\n            };\\n\\n            babelHelpers;\\n\\n            // for the sake of Safari, may it burn in hell\\n            var BLACKLIST = ['length', 'parentRule'];\\n\\n            var styleKeys = undefined;\\n\\n            if (typeof CSS2Properties !== 'undefined') {\\n            \\t// why hello Firefox\\n            \\tstyleKeys = Object.keys(CSS2Properties.prototype);\\n            } else {\\n            \\tstyleKeys = Object.keys(document.createElement('div').style).filter(function (k) {\\n            \\t\\treturn ! ~BLACKLIST.indexOf(k);\\n            \\t});\\n            }\\n\\n            var styleKeys$1 = styleKeys;\\n\\n            var svgns = 'http://www.w3.org/2000/svg';\\n            var svg = undefined;\\n            try {\\n            \\tsvg = document.createElementNS(svgns, 'svg');\\n\\n            \\tsvg.style.position = 'fixed';\\n            \\tsvg.style.top = svg.style.left = '0';\\n            \\tsvg.style.width = svg.style.height = '100%';\\n            \\tsvg.style.overflow = 'visible';\\n            \\tsvg.style.pointerEvents = 'none';\\n            \\tsvg.setAttribute('class', 'mogrify-svg');\\n            } catch (e) {\\n            \\tconsole.log(\\\"The current browser doesn't support SVG\\\");\\n            }\\n\\n            var appendedSvg = false;\\n\\n            function appendSvg() {\\n            \\tdocument.body.appendChild(svg);\\n            \\tappendedSvg = true;\\n            }\\n\\n            function cloneNode(node, depth, overrideClone) {\\n            \\tvar clone = overrideClone ? overrideClone(node, depth) : node.cloneNode();\\n\\n            \\tif (typeof clone === \\\"undefined\\\") {\\n            \\t\\treturn;\\n            \\t}\\n\\n            \\tvar style = undefined;\\n            \\tvar len = undefined;\\n            \\tvar i = undefined;\\n            \\tvar clonedNode = undefined;\\n\\n            \\tif (node.nodeType === 1) {\\n            \\t\\tstyle = window.getComputedStyle(node);\\n\\n            \\t\\tstyleKeys$1.forEach(function (prop) {\\n            \\t\\t\\tclone.style[prop] = style[prop];\\n            \\t\\t});\\n\\n            \\t\\tlen = node.childNodes.length;\\n            \\t\\tfor (i = 0; i < len; i += 1) {\\n            \\t\\t\\tclonedNode = cloneNode(node.childNodes[i], depth + 1, overrideClone);\\n            \\t\\t\\tif (clonedNode) {\\n            \\t\\t\\t\\tclone.appendChild(clonedNode);\\n            \\t\\t\\t}\\n            \\t\\t}\\n            \\t}\\n\\n            \\treturn clone;\\n            }\\n\\n            function wrapNode(node, destinationIsFixed, overrideClone, appendToBody) {\\n            \\tvar isSvg = node.namespaceURI === svgns;\\n\\n            \\tvar _node$getBoundingClie = node.getBoundingClientRect();\\n\\n            \\tvar left = _node$getBoundingClie.left;\\n            \\tvar right = _node$getBoundingClie.right;\\n            \\tvar top = _node$getBoundingClie.top;\\n            \\tvar bottom = _node$getBoundingClie.bottom;\\n\\n            \\tvar style = window.getComputedStyle(node);\\n            \\tvar clone = cloneNode(node, 0, overrideClone);\\n\\n            \\tvar wrapper = {\\n            \\t\\tnode: node, clone: clone, isSvg: isSvg,\\n            \\t\\tcx: (left + right) / 2,\\n            \\t\\tcy: (top + bottom) / 2,\\n            \\t\\twidth: right - left,\\n            \\t\\theight: bottom - top,\\n            \\t\\ttransform: null,\\n            \\t\\tborderRadius: null\\n            \\t};\\n\\n            \\tif (isSvg) {\\n            \\t\\tvar ctm = node.getScreenCTM();\\n            \\t\\twrapper.transform = 'matrix(' + [ctm.a, ctm.b, ctm.c, ctm.d, ctm.e, ctm.f].join(',') + ')';\\n            \\t\\twrapper.borderRadius = [0, 0, 0, 0];\\n\\n            \\t\\tsvg.appendChild(clone);\\n            \\t} else {\\n\\n            \\t\\tif (destinationIsFixed) {\\n            \\t\\t\\t// position relative to the viewport\\n            \\t\\t\\tclone.style.position = 'fixed';\\n            \\t\\t\\tclone.style.top = top - parseInt(style.marginTop, 10) + 'px';\\n            \\t\\t\\tclone.style.left = left - parseInt(style.marginLeft, 10) + 'px';\\n            \\t\\t} else {\\n            \\t\\t\\tvar offsetParent = node.offsetParent;\\n\\n            \\t\\t\\tif (offsetParent === null || offsetParent === document.body || appendToBody) {\\n            \\t\\t\\t\\t// parent is fixed, or I want to append the node to the body\\n            \\t\\t\\t\\t// position relative to the document\\n            \\t\\t\\t\\tvar docElem = document.documentElement;\\n            \\t\\t\\t\\tclone.style.position = 'absolute';\\n            \\t\\t\\t\\tclone.style.top = top + window.pageYOffset - docElem.clientTop - parseInt(style.marginTop, 10) + 'px';\\n            \\t\\t\\t\\tclone.style.left = left + window.pageXOffset - docElem.clientLeft - parseInt(style.marginLeft, 10) + 'px';\\n            \\t\\t\\t} else {\\n            \\t\\t\\t\\t//position relative to the parent\\n            \\t\\t\\t\\tvar offsetParentStyle = window.getComputedStyle(offsetParent);\\n            \\t\\t\\t\\tvar offsetParentBcr = offsetParent.getBoundingClientRect();\\n\\n            \\t\\t\\t\\tclone.style.position = 'absolute';\\n            \\t\\t\\t\\tclone.style.top = top - parseInt(style.marginTop, 10) - (offsetParentBcr.top - parseInt(offsetParentStyle.marginTop, 10)) + 'px';\\n            \\t\\t\\t\\tclone.style.left = left - parseInt(style.marginLeft, 10) - (offsetParentBcr.left - parseInt(offsetParentStyle.marginLeft, 10)) + 'px';\\n            \\t\\t\\t}\\n            \\t\\t}\\n\\n            \\t\\twrapper.transform = ''; // TODO...?\\n            \\t\\twrapper.borderRadius = [parseFloat(style.borderTopLeftRadius), parseFloat(style.borderTopRightRadius), parseFloat(style.borderBottomRightRadius), parseFloat(style.borderBottomLeftRadius)];\\n\\n            \\t\\tif (appendToBody) {\\n            \\t\\t\\tdocument.body.appendChild(clone);\\n            \\t\\t} else {\\n            \\t\\t\\tnode.parentNode.appendChild(clone);\\n            \\t\\t}\\n            \\t}\\n\\n            \\treturn wrapper;\\n            }\\n\\n            function hideNode(node) {\\n            \\tnode.__ramjetOriginalTransition__ = node.style.transition;\\n            \\tnode.style.transition = '';\\n\\n            \\tnode.style.opacity = 0;\\n            }\\n\\n            function showNode(node) {\\n            \\tnode.style.transition = '';\\n            \\tnode.style.opacity = 1;\\n\\n            \\tif (node.__ramjetOriginalTransition__) {\\n            \\t\\tsetTimeout(function () {\\n            \\t\\t\\tnode.style.transition = node.__ramjetOriginalTransition__;\\n            \\t\\t});\\n            \\t}\\n            }\\n\\n            function isNodeFixed(node) {\\n            \\twhile (node !== null) {\\n            \\t\\tif (window.getComputedStyle(node).position === \\\"fixed\\\") {\\n            \\t\\t\\treturn true;\\n            \\t\\t}\\n            \\t\\tnode = node.namespaceURI === svgns ? node.parentNode : node.offsetParent;\\n            \\t}\\n            \\treturn false;\\n            }\\n\\n            function getTransform(isSvg, cx, cy, dx, dy, dsx, dsy, t, t_scale) {\\n            \\tvar transform = isSvg ? \\\"translate(\\\" + cx + \\\" \\\" + cy + \\\") scale(\\\" + (1 + t_scale * dsx) + \\\" \\\" + (1 + t_scale * dsy) + \\\") translate(\\\" + -cx + \\\" \\\" + -cy + \\\") translate(\\\" + t * dx + \\\" \\\" + t * dy + \\\")\\\" : \\\"translate(\\\" + t * dx + \\\"px,\\\" + t * dy + \\\"px) scale(\\\" + (1 + t_scale * dsx) + \\\",\\\" + (1 + t_scale * dsy) + \\\")\\\";\\n\\n            \\treturn transform;\\n            }\\n\\n            function getBorderRadius(a, b, dsx, dsy, t) {\\n            \\tvar sx = 1 + t * dsx;\\n            \\tvar sy = 1 + t * dsy;\\n\\n            \\treturn a.map(function (from, i) {\\n            \\t\\tvar to = b[i];\\n\\n            \\t\\tvar rx = (from + t * (to - from)) / sx;\\n            \\t\\tvar ry = (from + t * (to - from)) / sy;\\n\\n            \\t\\treturn rx + \\\"px \\\" + ry + \\\"px\\\";\\n            \\t});\\n            }\\n\\n            function linear(pos) {\\n            \\treturn pos;\\n            }\\n\\n            function easeIn(pos) {\\n            \\treturn Math.pow(pos, 3);\\n            }\\n\\n            function easeOut(pos) {\\n            \\treturn Math.pow(pos - 1, 3) + 1;\\n            }\\n\\n            function easeInOut(pos) {\\n            \\tif ((pos /= 0.5) < 1) {\\n            \\t\\treturn 0.5 * Math.pow(pos, 3);\\n            \\t}\\n\\n            \\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\\n            }\\n\\n            var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\\n                        return setTimeout(fn, 16);\\n            };\\n\\n            var TimerTransformer = function TimerTransformer(from, to, options) {\\n            \\tbabelHelpers.classCallCheck(this, TimerTransformer);\\n\\n            \\tvar dx = to.cx - from.cx;\\n            \\tvar dy = to.cy - from.cy;\\n\\n            \\tvar dsxf = to.width / from.width - 1;\\n            \\tvar dsyf = to.height / from.height - 1;\\n\\n            \\tvar dsxt = from.width / to.width - 1;\\n            \\tvar dsyt = from.height / to.height - 1;\\n\\n            \\tvar startTime = Date.now();\\n            \\tvar duration = options.duration || 400;\\n            \\tvar easing = options.easing || linear;\\n            \\tvar easingScale = options.easingScale || easing;\\n\\n            \\tfunction tick() {\\n            \\t\\tvar timeNow = Date.now();\\n            \\t\\tvar elapsed = timeNow - startTime;\\n\\n            \\t\\tif (elapsed > duration) {\\n            \\t\\t\\tfrom.clone.parentNode.removeChild(from.clone);\\n            \\t\\t\\tto.clone.parentNode.removeChild(to.clone);\\n\\n            \\t\\t\\tif (options.done) {\\n            \\t\\t\\t\\toptions.done();\\n            \\t\\t\\t}\\n\\n            \\t\\t\\treturn;\\n            \\t\\t}\\n\\n            \\t\\tvar t = easing(elapsed / duration);\\n            \\t\\tvar t_scale = easingScale(elapsed / duration);\\n\\n            \\t\\t// opacity\\n            \\t\\tfrom.clone.style.opacity = 1 - t;\\n            \\t\\tto.clone.style.opacity = t;\\n\\n            \\t\\t// border radius\\n            \\t\\tvar fromBorderRadius = getBorderRadius(from.borderRadius, to.borderRadius, dsxf, dsyf, t);\\n            \\t\\tvar toBorderRadius = getBorderRadius(to.borderRadius, from.borderRadius, dsxt, dsyt, 1 - t);\\n\\n            \\t\\tapplyBorderRadius(from.clone, fromBorderRadius);\\n            \\t\\tapplyBorderRadius(to.clone, toBorderRadius);\\n\\n            \\t\\tvar cx = from.cx + dx * t;\\n            \\t\\tvar cy = from.cy + dy * t;\\n\\n            \\t\\tvar fromTransform = getTransform(from.isSvg, cx, cy, dx, dy, dsxf, dsyf, t, t_scale) + ' ' + from.transform;\\n            \\t\\tvar toTransform = getTransform(to.isSvg, cx, cy, -dx, -dy, dsxt, dsyt, 1 - t, 1 - t_scale) + ' ' + to.transform;\\n\\n            \\t\\tif (from.isSvg) {\\n            \\t\\t\\tfrom.clone.setAttribute('transform', fromTransform);\\n            \\t\\t} else {\\n            \\t\\t\\tfrom.clone.style.transform = from.clone.style.webkitTransform = from.clone.style.msTransform = fromTransform;\\n            \\t\\t}\\n\\n            \\t\\tif (to.isSvg) {\\n            \\t\\t\\tto.clone.setAttribute('transform', toTransform);\\n            \\t\\t} else {\\n            \\t\\t\\tto.clone.style.transform = to.clone.style.webkitTransform = to.clone.style.msTransform = toTransform;\\n            \\t\\t}\\n\\n            \\t\\trAF(tick);\\n            \\t}\\n\\n            \\ttick();\\n            };\\n\\n            function applyBorderRadius(node, borderRadius) {\\n            \\tnode.style.borderTopLeftRadius = borderRadius[0];\\n            \\tnode.style.borderTopRightRadius = borderRadius[1];\\n            \\tnode.style.borderBottomRightRadius = borderRadius[2];\\n            \\tnode.style.borderBottomLeftRadius = borderRadius[3];\\n            }\\n\\n            var div = document.createElement('div');\\n\\n            var keyframesSupported = true;\\n            var TRANSFORM = undefined;\\n            var KEYFRAMES = undefined;\\n            var ANIMATION_DIRECTION = undefined;\\n            var ANIMATION_DURATION = undefined;\\n            var ANIMATION_ITERATION_COUNT = undefined;\\n            var ANIMATION_NAME = undefined;\\n            var ANIMATION_TIMING_FUNCTION = undefined;\\n            var ANIMATION_END = undefined;\\n\\n            // We have to browser-sniff for IE11, because it was apparently written\\n            // by a barrel of stoned monkeys - http://jsfiddle.net/rich_harris/oquLu2qL/\\n\\n            // http://stackoverflow.com/questions/17907445/how-to-detect-ie11\\n            var isIe11 = !window.ActiveXObject && 'ActiveXObject' in window;\\n\\n            if (!isIe11 && ('transform' in div.style || 'webkitTransform' in div.style) && ('animation' in div.style || 'webkitAnimation' in div.style)) {\\n            \\tkeyframesSupported = true;\\n\\n            \\tTRANSFORM = 'transform' in div.style ? 'transform' : '-webkit-transform';\\n\\n            \\tif ('animation' in div.style) {\\n            \\t\\tKEYFRAMES = '@keyframes';\\n\\n            \\t\\tANIMATION_DIRECTION = 'animationDirection';\\n            \\t\\tANIMATION_DURATION = 'animationDuration';\\n            \\t\\tANIMATION_ITERATION_COUNT = 'animationIterationCount';\\n            \\t\\tANIMATION_NAME = 'animationName';\\n            \\t\\tANIMATION_TIMING_FUNCTION = 'animationTimingFunction';\\n\\n            \\t\\tANIMATION_END = 'animationend';\\n            \\t} else {\\n            \\t\\tKEYFRAMES = '@-webkit-keyframes';\\n\\n            \\t\\tANIMATION_DIRECTION = 'webkitAnimationDirection';\\n            \\t\\tANIMATION_DURATION = 'webkitAnimationDuration';\\n            \\t\\tANIMATION_ITERATION_COUNT = 'webkitAnimationIterationCount';\\n            \\t\\tANIMATION_NAME = 'webkitAnimationName';\\n            \\t\\tANIMATION_TIMING_FUNCTION = 'webkitAnimationTimingFunction';\\n\\n            \\t\\tANIMATION_END = 'webkitAnimationEnd';\\n            \\t}\\n            } else {\\n            \\tkeyframesSupported = false;\\n            }\\n\\n            var KeyframeTransformer = function KeyframeTransformer(from, to, options) {\\n            \\tbabelHelpers.classCallCheck(this, KeyframeTransformer);\\n\\n            \\tvar _getKeyframes = getKeyframes(from, to, options);\\n\\n            \\tvar fromKeyframes = _getKeyframes.fromKeyframes;\\n            \\tvar toKeyframes = _getKeyframes.toKeyframes;\\n\\n            \\tvar fromId = '_' + ~ ~(Math.random() * 1000000);\\n            \\tvar toId = '_' + ~ ~(Math.random() * 1000000);\\n\\n            \\tvar css = KEYFRAMES + ' ' + fromId + ' { ' + fromKeyframes + ' } ' + KEYFRAMES + ' ' + toId + ' { ' + toKeyframes + ' }';\\n            \\tvar dispose = addCss(css);\\n\\n            \\tfrom.clone.style[ANIMATION_DIRECTION] = 'alternate';\\n            \\tfrom.clone.style[ANIMATION_DURATION] = options.duration / 1000 + 's';\\n            \\tfrom.clone.style[ANIMATION_ITERATION_COUNT] = 1;\\n            \\tfrom.clone.style[ANIMATION_NAME] = fromId;\\n            \\tfrom.clone.style[ANIMATION_TIMING_FUNCTION] = 'linear';\\n\\n            \\tto.clone.style[ANIMATION_DIRECTION] = 'alternate';\\n            \\tto.clone.style[ANIMATION_DURATION] = options.duration / 1000 + 's';\\n            \\tto.clone.style[ANIMATION_ITERATION_COUNT] = 1;\\n            \\tto.clone.style[ANIMATION_NAME] = toId;\\n            \\tto.clone.style[ANIMATION_TIMING_FUNCTION] = 'linear';\\n\\n            \\tvar fromDone = undefined;\\n            \\tvar toDone = undefined;\\n\\n            \\tfunction done() {\\n            \\t\\tif (fromDone && toDone) {\\n            \\t\\t\\tfrom.clone.parentNode.removeChild(from.clone);\\n            \\t\\t\\tto.clone.parentNode.removeChild(to.clone);\\n\\n            \\t\\t\\tif (options.done) options.done();\\n\\n            \\t\\t\\tdispose();\\n            \\t\\t}\\n            \\t}\\n\\n            \\tfrom.clone.addEventListener(ANIMATION_END, function () {\\n            \\t\\tfromDone = true;\\n            \\t\\tdone();\\n            \\t});\\n\\n            \\tto.clone.addEventListener(ANIMATION_END, function () {\\n            \\t\\ttoDone = true;\\n            \\t\\tdone();\\n            \\t});\\n            };\\n\\n            function addCss(css) {\\n            \\tvar styleElement = document.createElement('style');\\n            \\tstyleElement.type = 'text/css';\\n\\n            \\tvar head = document.getElementsByTagName('head')[0];\\n\\n            \\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\\n            \\t// use styleSheet.cssText instead\\n            \\tvar styleSheet = styleElement.styleSheet;\\n\\n            \\tif (styleSheet) {\\n            \\t\\tstyleSheet.cssText = css;\\n            \\t} else {\\n            \\t\\tstyleElement.innerHTML = css;\\n            \\t}\\n\\n            \\thead.appendChild(styleElement);\\n\\n            \\treturn function () {\\n            \\t\\treturn head.removeChild(styleElement);\\n            \\t};\\n            }\\n\\n            function getKeyframes(from, to, options) {\\n            \\tvar dx = to.cx - from.cx;\\n            \\tvar dy = to.cy - from.cy;\\n\\n            \\tvar dsxf = to.width / from.width - 1;\\n            \\tvar dsyf = to.height / from.height - 1;\\n\\n            \\tvar dsxt = from.width / to.width - 1;\\n            \\tvar dsyt = from.height / to.height - 1;\\n\\n            \\tvar easing = options.easing || linear;\\n            \\tvar easingScale = options.easingScale || easing;\\n\\n            \\tvar numFrames = options.duration / 50; // one keyframe per 50ms is probably enough... this may prove not to be the case though\\n\\n            \\tvar fromKeyframes = [];\\n            \\tvar toKeyframes = [];\\n            \\tvar i;\\n\\n            \\tfunction addKeyframes(pc, t, t_scale) {\\n            \\t\\tvar cx = from.cx + dx * t;\\n            \\t\\tvar cy = from.cy + dy * t;\\n\\n            \\t\\tvar fromBorderRadius = getBorderRadius(from.borderRadius, to.borderRadius, dsxf, dsyf, t);\\n            \\t\\tvar toBorderRadius = getBorderRadius(to.borderRadius, from.borderRadius, dsxt, dsyt, 1 - t);\\n\\n            \\t\\tvar fromTransform = getTransform(false, cx, cy, dx, dy, dsxf, dsyf, t, t_scale) + ' ' + from.transform;\\n            \\t\\tvar toTransform = getTransform(false, cx, cy, -dx, -dy, dsxt, dsyt, 1 - t, 1 - t_scale) + ' ' + to.transform;\\n\\n            \\t\\tfromKeyframes.push('\\\\n\\\\t\\\\t\\\\t' + pc + '% {\\\\n\\\\t\\\\t\\\\t\\\\topacity: ' + (1 - t) + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-left-radius: ' + fromBorderRadius[0] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-right-radius: ' + fromBorderRadius[1] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-right-radius: ' + fromBorderRadius[2] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-left-radius: ' + fromBorderRadius[3] + ';\\\\n\\\\t\\\\t\\\\t\\\\t' + TRANSFORM + ': ' + fromTransform + ';\\\\n\\\\t\\\\t\\\\t}');\\n\\n            \\t\\ttoKeyframes.push('\\\\n\\\\t\\\\t\\\\t' + pc + '% {\\\\n\\\\t\\\\t\\\\t\\\\topacity: ' + t + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-left-radius: ' + toBorderRadius[0] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-top-right-radius: ' + toBorderRadius[1] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-right-radius: ' + toBorderRadius[2] + ';\\\\n\\\\t\\\\t\\\\t\\\\tborder-bottom-left-radius: ' + toBorderRadius[3] + ';\\\\n\\\\t\\\\t\\\\t\\\\t' + TRANSFORM + ': ' + toTransform + ';\\\\n\\\\t\\\\t\\\\t}');\\n            \\t}\\n\\n            \\tfor (i = 0; i < numFrames; i += 1) {\\n            \\t\\tvar pc = 100 * (i / numFrames);\\n            \\t\\tvar t = easing(i / numFrames);\\n            \\t\\tvar t_scale = easingScale(i / numFrames);\\n\\n            \\t\\taddKeyframes(pc, t, t_scale);\\n            \\t}\\n\\n            \\taddKeyframes(100, 1, 1);\\n\\n            \\tfromKeyframes = fromKeyframes.join('\\\\n');\\n            \\ttoKeyframes = toKeyframes.join('\\\\n');\\n\\n            \\treturn { fromKeyframes: fromKeyframes, toKeyframes: toKeyframes };\\n            }\\n\\n            var ramjet = {\\n            \\ttransform: function transform(fromNode, toNode) {\\n            \\t\\tvar options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\\n\\n            \\t\\tif (typeof options === 'function') {\\n            \\t\\t\\toptions = { done: options };\\n            \\t\\t}\\n\\n            \\t\\tif (!('duration' in options)) {\\n            \\t\\t\\toptions.duration = 400;\\n            \\t\\t}\\n\\n            \\t\\tvar appendToBody = !!options.appendToBody;\\n            \\t\\tvar destinationIsFixed = isNodeFixed(toNode);\\n            \\t\\tvar from = wrapNode(fromNode, destinationIsFixed, options.overrideClone, appendToBody);\\n            \\t\\tvar to = wrapNode(toNode, destinationIsFixed, options.overrideClone, appendToBody);\\n\\n            \\t\\tif (from.isSvg || to.isSvg && !appendedSvg) {\\n            \\t\\t\\tappendSvg();\\n            \\t\\t}\\n\\n            \\t\\tif (!keyframesSupported || options.useTimer || from.isSvg || to.isSvg) {\\n            \\t\\t\\treturn new TimerTransformer(from, to, options);\\n            \\t\\t} else {\\n            \\t\\t\\treturn new KeyframeTransformer(from, to, options);\\n            \\t\\t}\\n            \\t},\\n            \\thide: function hide() {\\n            \\t\\tfor (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\\n            \\t\\t\\tnodes[_key] = arguments[_key];\\n            \\t\\t}\\n\\n            \\t\\tnodes.forEach(hideNode);\\n            \\t},\\n            \\tshow: function show() {\\n            \\t\\tfor (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n            \\t\\t\\tnodes[_key2] = arguments[_key2];\\n            \\t\\t}\\n\\n            \\t\\tnodes.forEach(showNode);\\n            \\t},\\n\\n            \\t// expose some basic easing functions\\n            \\tlinear: linear, easeIn: easeIn, easeOut: easeOut, easeInOut: easeInOut\\n            };\\n\\n            return ramjet;\\n\\n}));\\n//# sourceMappingURL=ramjet.umd.js.map\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/philmerrell/dev/Scrum-Poker/~/raw-loader!/Users/philmerrell/dev/Scrum-Poker/~/ramjet/dist/ramjet.umd.js\n// module id = 793\n// module chunks = 1"],"sourceRoot":""}